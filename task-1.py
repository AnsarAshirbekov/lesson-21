# а) Напишите скрипт, который будет создавать виртуальное окружение и
# устанавливать туда библиотеку python-docx.
# б) Напишите пример приложения на input, которое получает текст от
# пользователя и создаёт word-файл с этим текстом.
# в) Соберите это приложение в исполняемый файл («.exe»).


# Чтобы создать виртуальное пространство, нужно открыть консоль и ввести команду: python -m venv myenv
# myenv в данном примере это название папки с виртуальным пространством, она создастся автоматически и внутри нее будет
# много всяких других папок.
# Здесь VScode предложит нам сменить интерпретатор с глобального на тот, который создался вместе с виртуальным
# пространством. Можем сменить его.
# Затем пытаемся активировать это виртуальное пространство с помощью команды: myenv\Scripts\activate

# Здесь может вылезти ошибка https:/go.microsoft.com/fwlink/?LinkID=135170. которая говорит нам, что политика выполнения
# скриптов в PowerShell не дает нам выполнить активацию. Дело в том, что когда мы открываем консоль, у нас открывается
# PowerShell в качестве оболочки терминала, VScode по умолчанию использует именно ее. В PowerShell есть такое понятие как
# ExecutionPolicy, которая регулирует выполнение скриптов и прочих конфигураций, предотвращая выполнение вредоносных 
# скриптов. Чтобы узнать, какой ExecutionPolicy сейчас стоит нужно ввести команду: Get-ExecutionPolicy
# По умолчанию там стоит всегда Restricted, что говорит о том, что PowerShell будет выполнять команды, но не будет выполнять
# скрипты, такое как правило устанавливается для клиентских компьютеров Windows. Чтобы поставить ему выполнение скриптов,
# необходимо сменить Restricted на RemoteSigned с помощью команды: Set-ExecutionPolicy RemoteSigned
# Но эту команду можно выполнить только в самом PowerShell(администратор) и такая политика сменится для всей системы
# глобально. Лучше это сделать только здесь, локально, через VScode. Но для этого нам нужно еще указать область, где будет
# задана политика. Для этого вводим команду: Set-ExecutionPolicy -Scope Process -ExecutionPolicy RemoteSigned
# -Scope здесь указывает на область, а Process говорит о том, что изменения будут применяться только в рамках текущего
# процесса PowerShell. Как только процесс PowerShell завершится (например, после закрытия Visual Studio Code или терминала), 
# параметры выполнения будут сброшены до предыдущих значений.

# Теперь мы можем активировать наше виртуальное пространство: myenv\Scripts\activate
# После этого мы будет находится как бы в его директории (myenv)
# Устанавливаем здесь библиотеку для работы с doc файлами командой: pip install python-docx
# Теперь если мы захотим работать с модулем docx, он у нас будет доступен для работы 
# Затем деактивируем виртуальное пространство командой: deactivate
# Здесь можно заметить то, что наши старые библиотеки, которые мы устанавливали до этого, стали недоступны.
# Это связано с тем, что мы изменили интерпретатор с глобального на виртуальный, когда VScode нам это предлагал.
# Чтобы вернуться обратно на глобальный, нужно нажать Ctrl + Shift + P и ввести Select Interpreter и выбрать Global
# Теперь наши старые библиотеки вернулись, а docx стал недоступен, так как мы его устанавливали в виртуальном интерпретаторе.
# Чтобы узнать какие библиотеки доступны в том или ином интерпретаторе, нужно, находясь в каком-то интерпретаторе, прописать
# команду: pip list и нам выведется список доступных библиотек интерпретатора.

# Все что мы делали до этого, была ручная работа по созданию виртуального пространства и установки в нем библиотеки docx.
# Но нам нужно автоматизировать этот процесс созданием скрипта, запустив который все эти действия происходили автоматически.

# Для этого создаем скрипт, воспользовавшись следующим библиотеками:
import os # предоставляет функции для взаимодействия с операционной системой.
import subprocess # позволяет запускать новые процессы, подключаться к их потокам ввода-вывода и получать их результаты.

# Создаем виртуальное окружение. Определяем имя для директории
venv_dir = "myenv"
# Здесь используем замечательную функцию run() из библиотеки subprocess, которая позволяет нам запускать команды, как-будто
# бы они вводились с консоли. Она принимает в качестве аргумента список, где каждый элемент представляет слово команды.
# Мы помним нашу команду для создания виртуального пространства: "python -m venv myenv". Делим строку на слова и передаем
# списком в функцию.
subprocess.run(["python", "-m", "venv", venv_dir])
# Потом мы активировали виртуальное пространство, но здесь делать этого нет необходимости, потому что мы далее будем 
# обращаться напрямую к pip, который будет устанавливать библиотеку docx. Когда мы активировали пространство с консоли, мы
# попадали в директорию папки Scripts внутри пространства, где находится файл pip. А здесь мы можем напрямую к нему обратиться.
# Помним нашу консольную команду для установки библиотеки: "pip install python-docx". Но нам здесь нужен тот pip, который
# находится в папке Scripts виртуального пространства. Для этого указываем путь, отталкиваясь от той директории, в которой
# мы сейчас находимся: .\myenv\Scripts\pip Чтобы сформировать путь, воспользуемся функцией path.join() из os, который из
# принимаемых аругментов сформировывает путь и возвращает строку, ведущую к необходимому файлу. 
pip_dir = os.path.join(venv_dir, "Scripts", "pip")
# Устанавливаем библиотеку python-docx в виртуальное окружение
subprocess.run([pip_dir, 'install', 'python-docx']) # "pip install python-docx"

# Теперь прописываем наш скрипт, для создания doc файла
# Подключаем библиотеку, нас здесь интересует только класс Document 
from docx import Document

# Получаем текст от пользователя
user_text = input("Введите текст: ")

# Создаем новый документ, объект класса
doc = Document()

# Добавляем текст в документ с помощью метода класса
doc.add_paragraph(user_text)

# Сохраняем документ, передав методу имя для файла
doc.save("user_text.docx")

print("Документ успешно создан!")

# Теперь вводим в консоли auto-py-to-exe для создания .exe файла


# ! ! !
# Полученный .exe файл при открытии создает виртуальное пространство и сразу же закрывается. И так каждый раз при открытии.
# До ввода текста и создания документа дело не доходит. 
# Если запускать этот скрипт здесь с консоли, то сначала он выдаст ошибку о том что библиотека docx не установлена, хотя
# он до этого ее сам же и устанавливал), а потом, запустив код еще раз, он уже запрашивает текст и создает документ с ним.
# Но все равно с какими-то Errno ошибками перед этим.
# Я думаю это связано с тем, что скрипт не успевает понять, что библиотека уже установлена, и выдает ошибку что ее нет.
# Я как это исправить я не знаю. 